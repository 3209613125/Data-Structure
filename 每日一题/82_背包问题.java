//* 背包问题：
//*
//* 有N件物品和一个容量为V的背包。第i件物品的价值是v[i]，重量是w[i]。
//* 求解将哪些物品装入背包可使价值总和最大。


class Main{
    public static void main(String[] args) {
        //物品数量
        int n = 5;
        //背包容量
        int m = 10;
        //五个物品依次的重量 需要考虑到以下对应的i(第几个物品)应该有其对应的重量
        int[] weight = {0,2,8,24,9,5};
        //五个物品依次的价值 需要考虑到以下对应的i(第几个物品)应该有其对应的价值
        int[] value = {0,8,30,50,25,6};
        //考虑到边界问题 第几个物品 剩余的空间大小
        int dp[][] = new int[n+1][m+1];

        for (int i = 1;i <= n;i++){
            for (int j = 1;j <= m;j++){
                //如果当前剩余空间j的大小大于该物品i的重量，那么可以考虑放和不放
                if (j >= weight[i]){
                    //考虑放到背包里，那么会产生两个问题，放之后的价值高还是放之前的价值高
                    int a = dp[i-1][j];//不放之前的价值
                    int b = dp[i-1][j-weight[i]]+value[i];//若放了，返回现有的价值
                    dp[i][j]=a > b ? a:b;//布尔值返回最大价值给当前dp[][]表示记录当前的价值
                }
                else {
                    //若根本不考虑放入背包，则返回之前的价值
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        //由于上述动态规划实际上是记录了一张二维表，后面的优先规划总是建立在之前的基础上，
        // 并将每次做出的规划记录下来(记录在二维表上)
        //最后我们需要返回二维数组最右下角的值，即dp[n][m]
        //为什么不是dp[n][m]，因为从0开始，已经算入了边界，所以是dp[n][m]
        System.out.println(dp[n][m]);
    }
}
